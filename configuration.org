* Display Settings

  I’ve been using Emacs for many years, and appreciate a certain
  minimalist approach to its display. While you can turn these off
  with the menu items now, it is just as easy to set them here.

  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    (setq initial-scratch-message "")
    (setq visible-bell t)

    (when (window-system)
      (tool-bar-mode -1)
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1))
      (scroll-bar-mode -1))

    (when (window-system) (progn
                            (set-face-attribute 'default
                                                nil
                                                :family "Iosevka"
                                                :width 'normal
                                                :height 130
                                                :weight 'light)

                            (setq-default line-spacing 4)       ; in pixels

                            ;; Enable ligatures.
                            (mac-auto-operator-composition-mode 1)))

    (when (eq system-type 'darwin)
      (setq mac-option-modifier 'meta))

    (fset 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  Use a full-screen frame:

  #+BEGIN_SRC emacs-lisp
    (toggle-frame-fullscreen)
  #+END_SRC

  Always show the current column in the modeline:

  #+BEGIN_SRC emacs-lisp
    (column-number-mode 1)
  #+END_SRC

  Properly display ANSI colours in compilation buffer output.  There is a
  [[http://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html][blog post]] about it.

  #+BEGIN_SRC emacs-lisp
    (require 'ansi-color)
    (defun dp/colourise-compilation ()
      "Colourise from `compilation-filter-start' to `point'."
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region compilation-filter-start (point))))
    (add-hook 'compilation-filter-hook #'dp/colourise-compilation)
  #+END_SRC

* General Settings

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is “good enough”, but I want it in its own file:

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Modernizing Emacs

   With a long history of working on small machines without gigabytes
   of RAM, we might as well let Emacs be the beast it has always
   dreamed of being.

   First, let’s increase the cache before starting garbage collection:

   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 50000000)
   #+END_SRC

   Found [[https://github.com/wasamasa/dotemacs/blob/master/init.org#init][here]] how to remove the warnings from the GnuTLS library when
   using HTTPS… increase the minimum prime bits size:

   #+BEGIN_SRC emacs-lisp
     (setq gnutls-min-prime-bits 4096)
   #+END_SRC

** Backups

  Store backups in dedicated directory ~backups~:

  #+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist
          (list (cons "." (expand-file-name "backups" user-emacs-directory))))

    (setq auto-save-list-file-prefix
          (expand-file-name "backups/auto-save-list/.saves-" user-emacs-directory))
  #+END_SRC

** Misc

  Tell Emacs who I am:

  #+BEGIN_SRC emacs-lisp
    (setq-default user-full-name    "David Porter"
                  user-mail-address "david.a.porter@gmail.com")
  #+END_SRC

  Suppress ~ad-handle-definition~ warnings (mostly from 3rd-party packages):

  #+BEGIN_SRC emacs-lisp
    (setq ad-redefinition-action 'accept)
  #+END_SRC

  Prevent extraneous tabs:

  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+END_SRC

  On OS X use the GNU Coreutils version of ~ls~ installed by Homebrew,
  which is called ~gls~:

  #+BEGIN_SRC emacs-lisp
    (when (eq system-type 'darwin)
      (setq insert-directory-program "gls"))
  #+END_SRC

  ~ibuffer~ is a bit nicer than ~list-buffers~:

  #+BEGIN_SRC emacs-lisp
    (defalias 'list-buffers 'ibuffer)
  #+END_SRC

  Wrap lines at close to 80 columns:

  #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 78)
  #+END_SRC

  Bind =M-x compile= to a convenient keybinding:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c c") 'compile)
  #+END_SRC

  Make the cursor a bit easier to find on the screen:
  #+BEGIN_SRC emacs-lisp
    (global-hl-line-mode 1)
  #+END_SRC

* ~use-package~
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (setq use-package-always-ensure t)
  #+END_SRC

* Theme

** Zenburn

   #+BEGIN_SRC emacs-lisp
     (use-package zenburn-theme
       :disabled
       :custom-face (region ((t (:background "#5F5F5F"))))
       :config (load-theme 'zenburn t))
   #+END_SRC

** SanityInc Tomorrow

   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-sanityinc-tomorrow
       :disabled
       :config (load-theme 'sanityinc-tomorrow-night t))
   #+END_SRC

** Typo

   I'm experimenting with using a non-colour theme. Instead of using colour to
   distinguish different kinds of text, it uses typography. The theme can be found [[https://github.com/bastibe/.emacs.d/blob/master/lisp/typo-theme.el][here]].

   #+BEGIN_SRC emacs-lisp
     (load-theme 'typo t)
   #+END_SRC

** Powerline

   Let's have a nice modeline appearance:

   #+BEGIN_SRC emacs-lisp
     (use-package powerline
       :config (powerline-default-theme))
   #+END_SRC

* Packages
** Exec Path from Shell
   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :config (progn
                 (setq exec-path-from-shell-arguments
                       (delete "-i" exec-path-from-shell-arguments))
                 (setq exec-path-from-shell-check-startup-files nil)
                 (exec-path-from-shell-initialize)))
   #+END_SRC

** Server
  Run as a server for use with ~emacsclient~.
  #+BEGIN_SRC emacs-lisp
    (use-package server
      :config (unless (server-running-p) (server-start)))
  #+END_SRC

** Which Key
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       ;; :after god-mode
       :config (progn
                 ;; (which-key-enable-god-mode-support)
                 (which-key-mode 1)))
   #+END_SRC

** Swiper, Counsel, Avy

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       ;; :after god-mode
       :bind (:map isearch-mode-map
                   ("C-." . swiper-from-isearch))
       :bind (:map swiper-map
                   ("M-h" . swiper-avy))
       ;; :bind (:map ivy-minibuffer-map
       ;;             ("<escape>" . dp/silent-god-local-mode))
       :config (progn
                 (setq ivy-use-virtual-buffers t)
                 (ivy-mode 1)))

     (use-package counsel
       :bind (("M-x"     . counsel-M-x)
              ("C-c C-r" . ivy-resume)
              ("C-c e" . counsel-recentf)
              ("C-x C-f" . counsel-find-file)
              ("<f1> f"  . counsel-describe-function)
              ("<f1> v"  . counsel-describe-variable)
              ("<f1> l"  . counsel-find-library)
              ("<f2> i"  . counsel-info-lookup-symbol)
              ("<f2> u"  . counsel-unicode-char)
              ("C-c g"   . counsel-git)
              ("C-c j"   . counsel-git-grep)
              ("C-c k"   . counsel-ag)
              ("C-x l"   . counsel-locate)
              ("M-y"     . counsel-yank-pop)))
   #+END_SRC

   In the following bindings for =avy-mode= the choices are made so that
   they're easy to type in =god-mode=. So for example, =M-g C-c= becomes
   =ggc=, =M-g C-w= becomes =ggw=, etc.

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :bind (("C-c C-," . avy-goto-char)
              ("C-c C-." . avy-goto-word-1)
              ("M-g C-g" . avy-goto-line))
       :config (avy-setup-default))
   #+END_SRC

** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :bind ("C-c C-<tab>" . company-complete)
       :hook (after-init . global-company-mode))
   #+END_SRC

** Undo Tree

   This replaces the standard Emacs undo system with the
   `undo-tree-mode' system in all buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :config (global-undo-tree-mode 1))
   #+END_SRC

** Ace Window
   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :bind ("C-x o" . ace-window))
   #+END_SRC

** Org

   We have to tell Org mode that it's okay to execute =sh= code:

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :config (progn
                 (org-babel-do-load-languages
                  'org-babel-load-languages '((sh . t)))
                 ;; syntax-highlight source code blocks:
                 (setq org-src-fontify-natively t)))
   #+END_SRC

   (We can add other languages to this list as the need arises.)

   Then we use a couple of Org helper packages. =org-bullets= replaces
   the asterisks in headings with nice glyphs:

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :after org
       :hook (org-mode . org-bullets-mode))
   #+END_SRC

   =org-journal= makes it easy to keep an Org mode-based journal:

   #+BEGIN_SRC emacs-lisp
     (use-package org-journal
       :after org
       :bind ("C-c C-j" . org-journal-new-entry))
   #+END_SRC

** WS Butler

   Trim whitespace from ends of lines.  But only lines that have been touched
   get trimmed.

   #+BEGIN_SRC emacs-lisp
     (use-package ws-butler
       :config (ws-butler-global-mode 1))
   #+END_SRC

** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind ("C-x g" . magit-status)
       :config (setq magit-completing-read-function 'ivy-completing-read))
   #+END_SRC

** Smartparens

   Here are the keybindings I'm using:

   |-------------------------+-------------------|
   | sp-beginning-of-sexp    | "C-M-a"           |
   | sp-end-of-sexp          | "C-M-e"           |
   | sp-forward-sexp         | "C-M-f"           |
   | sp-backward-sexp        | "C-M-b"           |
   | sp-next-sexp            | "C-M-n"           |
   | sp-previous-sexp        | "C-M-p"           |
   | sp-forward-symbol       | "C-S-f"           |
   | sp-backward-symbol      | "C-S-b"           |
   |-------------------------+-------------------|
   | sp-down-sexp            | "C-M-d"           |
   | sp-up-sexp              | "C-S-u"           |
   | sp-backward-down-sexp   | "C-S-d"           |
   | sp-backward-up-sexp     | "C-M-u"           |
   |-------------------------+-------------------|
   | sp-unwrap-sexp          | "M-]"             |
   | sp-backward-unwrap-sexp | "M-["             |
   | sp-forward-slurp-sexp   | "C-<right>"       |
   | sp-forward-barf-sexp    | "C-<left>"        |
   | sp-backward-slurp-sexp  | "C-M-<left>"      |
   | sp-backward-barf-sexp   | "C-M-<right>"     |
   |-------------------------+-------------------|
   | sp-transpose-sexp       | "C-M-t"           |
   | sp-mark-sexp            | "C-M-SPC"         |
   | sp-copy-sexp            | "C-M-w"           |
   | sp-kill-sexp            | "C-M-k"           |
   | sp-backward-kill-sexp   | "M-<backspace>"   |
   | sp-kill-hybrid-sexp     | "C-k"             |
   | sp-kill-whole-line      | "C-S-<backspace>" |
   |--------------------------+-------------------|

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens-config
       :ensure smartparens
       :bind (:map sp-keymap
                   ("C-M-a"           . sp-beginning-of-sexp)
                   ("C-M-e"           . sp-end-of-sexp)
                   ("C-S-u"           . sp-up-sexp)
                   ("C-S-d"           . sp-backward-down-sexp)
                   ("C-S-f"           . sp-forward-symbol)
                   ("C-S-b"           . sp-backward-symbol)
                   ("M-]"             . sp-unwrap-sexp)
                   ("M-["             . sp-backward-unwrap-sexp)
                   ("C-M-t"           . sp-transpose-sexp)
                   ("M-<backspace>"   . sp-backward-kill-sexp)
                   ("C-S-<backspace>" . sp-kill-whole-line))
       :config (progn
                 (setq sp-base-key-bindings 'sp)
                 (smartparens-global-strict-mode 1)
                 (show-smartparens-global-mode 1)
                 (sp-use-smartparens-bindings)))
   #+END_SRC

   Note that, according to the documentation, the way to specify which
   default set of keybindings to use is to set the variable
   =sp-base-key-bindings=. However, I couldn't get that to work so I
   just call =sp-use-smartparens-bindings= as well.

** Paren-Face

   Make parentheses less visible by dimming them.

   #+BEGIN_SRC emacs-lisp
     (use-package paren-face
       :config (global-paren-face-mode))
   #+END_SRC

** Projectile
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :config (progn
                 (setq projectile-completion-system 'ivy)
                 (projectile-mode 1)))
   #+END_SRC

   Counsel-projectile provides further Ivy integration with Projectile
   by taking advantage of Ivy's mechanism to select from a list of
   actions and/or apply an action without leaving the completion
   session. The main keybinding for invoking Projectile becomes =C-c p
   SPC=.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :after projectile
       :commands counsel-projectile
       :config (counsel-projectile-on))
   #+END_SRC

** Spelling

   #+BEGIN_SRC emacs-lisp
     (use-package ispell
       :commands (ispell-word
                  ispell-region
                  ispell-buffer)
       :config (when (executable-find "hunspell")
                 (setq-default ispell-program-name "hunspell")
                 (setq ispell-really-hunspell t)))

     (use-package flyspell
       :commands (flyspell-mode
                  turn-on-flyspell
                  turn-off-flyspell
                  flyspell-prog-mode)
       :hook (((text-mode git-commit-mode-hook) . flyspell-mode)
              (prog-mode . flyspell-prog-mode)))
   #+END_SRC

** Define Word
   #+BEGIN_SRC emacs-lisp
     (use-package define-word
       :bind (("C-c w" . define-word-at-point)
              ("C-c W" . define-word)))
   #+END_SRC

** Keyfreq

   I'm interested in choosing more comfortable keybindings for my
   most-used commands.  In order to find out which commands these are
   I use =keyfreq=.

   View the statistics by invoking =keyfreq-show= and checking the
   resulting buffer =*frequencies*=.

   #+BEGIN_SRC emacs-lisp
     (use-package keyfreq
       :config (progn
                 (keyfreq-mode 1)
                 (keyfreq-autosave-mode 1)))
   #+END_SRC

** God Mode

   #+BEGIN_SRC emacs-lisp
     (use-package god-mode
       :disabled
       :after switch-buffer-functions
       :demand t
       :bind ("<escape>" . god-local-mode)
       :bind (:map god-local-mode-map
                   ("i" . god-local-mode)
                   ("." . repeat))
       :bind (:map minibuffer-local-map
                   ("<escape>" . dp/silent-god-local-mode))
       :config (progn
                 (defun dp/silent-god-local-mode ()
                   (interactive)
                   (cl-letf (((symbol-function #'message) #'ignore))
                     (call-interactively #'god-local-mode)))

                 (defun dp/god-mode-update-cursor ()
                   (cond (god-local-mode
                          (progn
                            ;; (set-cursor-color "#DCA3A3") ; zenburn-red+1
                            (set-cursor-color "#dc322f") ; solarized red
                            (setq cursor-type 'box)))
                         (buffer-read-only
                          (progn
                            ;; (set-cursor-color "#DCDCCC") ; zenburn-fg
                            (set-cursor-color "#93a1a1") ; solarized base1
                            (setq cursor-type 'box)))
                         (t
                          (progn
                            (set-cursor-color "#002b36")
                            (setq cursor-type 'bar)))))

                 (add-hook 'god-mode-enabled-hook 'dp/god-mode-update-cursor)
                 (add-hook 'god-mode-disabled-hook 'dp/god-mode-update-cursor)
                 (add-hook 'switch-buffer-functions
                           (lambda (prev cur)
                             (dp/god-mode-update-cursor)))

                 (add-to-list 'god-exempt-major-modes 'info-mode)
                 (god-mode)))

     (use-package god-mode-isearch
       :disabled
       :ensure god-mode
       :bind (:map isearch-mode-map
                   ("<escape>" . god-mode-isearch-activate))
       :bind (:map god-mode-isearch-map
                   ("<escape>" . god-mode-isearch-disable)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package switch-buffer-functions
       :disabled)
   #+END_SRC

** Flycheck

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :config (global-flycheck-mode 1))

     (use-package avy-flycheck
       :after (avy flycheck)
       :config (avy-flycheck-setup))
   #+END_SRC

** YASnippet

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :commands (yas-minor-mode)
       :hook (prog-mode . yas-minor-mode)
       :config (yas-reload-all))

     (use-package yasnippet-snippets
       :after yasnippet)
   #+END_SRC

** Aggressive Indent

   =aggressive-indent-mode= is a minor mode that ensures code is always
   indented. It automatically re-indents after every change.

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :config (global-aggressive-indent-mode 1))
   #+END_SRC

** Visible Mark

   I'm going to use this temporarily to help me understand how the mark works
   in Emacs:

   #+BEGIN_SRC emacs-lisp
     (use-package visible-mark
       :custom-face (visible-mark-face1
                     ((t (:inherit avy-lead-face-1))))
       :custom-face (visible-mark-face2
                     ((t (:inherit avy-lead-face-0))))
       :config (progn
                 (setq visible-mark-max 2)
                 (setq visible-mark-faces
                       '(visible-mark-face1 visible-mark-face2))
                 (global-visible-mark-mode 1)))
   #+END_SRC

** Ruby

   Enable a Ruby REPL:

   #+BEGIN_SRC emacs-lisp
     (use-package inf-ruby
       :hook (ruby-mode . inf-ruby-minor-mode))
   #+END_SRC

   Robe provides code navigation, documentation lookup and completion for
   Ruby.

   #+BEGIN_SRC emacs-lisp
     (use-package robe
       :after company
       :hook ruby-mode
       :init (push 'company-robe company-backends))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package dash-at-point
       :commands dash-at-point
       :bind ("C-c d" . dash-at-point))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package yari)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-tools
       :hook ruby-mode)
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (use-package rvm
       :hook (ruby-mode . rvm-activate-corresponding-ruby)
       :config (rvm-use-default))
   #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :mode "\\.markdown\\'"
       :commands markdown-mode)

     (use-package markdown-mode+
       :after markdown-mode)
   #+END_SRC

** Twitter
   #+BEGIN_SRC emacs-lisp
     (use-package twittering-mode
       :commands twit)
   #+END_SRC

** YAML
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :mode "\\.yaml\\'")
   #+END_SRC

** Try
   #+BEGIN_SRC emacs-lisp
     (use-package try
       :commands try)
   #+END_SRC

** Gnus

   Store =.gnus.el= in =~/.emacs.d=:

   #+BEGIN_SRC emacs-lisp
     (setq gnus-init-file (expand-file-name "gnus.el" user-emacs-directory))
   #+END_SRC
